#!/usr/bin/env python

import os.path
import shutil
import subprocess
import multiprocessing
import signal
import re
import glob
import argparse
import configparser
import tracer, angr, simuvex, driller, fuzzer
from ui.console import ConsoleUI
import modules.banner, modules.binInfo, modules.menu
import modules.fuzzerStats

CHECK_INTERVAL = 10

def checkFuzzerStatus(signum, frame):
    
    # Refresh our display
    console.draw()    

    # If we have no more pending favs, we should move on.
    pending_favs = sum(int(fuzz.stats[x]['pending_favs']) for x in fuzz.stats)

    # It's time to drill for some more
    #if pending_favs == 0:
    #    doDrill()

    # Reset our alarm
    signal.alarm(CHECK_INTERVAL)

def doDrill():
    # Inform the UI
    fuzzstats.drilling = True
    
    # Stop the current fuzzing efforts to allow CPU to focus on driller
    fuzz.kill()
    
    
    

def preChecks():
    # Checking for files that are needed
    if shutil.which("afl-fuzz") == None:
        print("Must have afl-fuzz installed: http://lcamtuf.coredump.cx/afl/")
        exit(1)

def getConfig():
    config = {}
    config['cycles_done'] = 0
    print("Setting up fuzz configuration")

    #target = input("Target Binary (full or relative path): ")
    target = args.binary[0]

    # Change it to abs path
    target = os.path.abspath(target)
    config["target"] = target
    
    # Ensure the file exists
    if not os.path.isfile(target):
        print("That file doesn't appear to exist...")
        exit(1)


    #cmdline = input("Command line args: ")
    #config["cmdline"] = cmdline

    defaultThreads = multiprocessing.cpu_count()
    #threads = input("Number of cores (default: {0}): ".format(defaultThreads))
    #threads = defaultThreads if threads == "" else int(threads)
    config["threads"] = defaultThreads
 

    #inDir = input("Test Case Dir (default: 'in/'): ")
    #inDir = "in" if inDir == "" else inDir
    workDir = os.path.abspath("work")
    config["workDir"] = workDir


    #outDir = input("Test Case Dir (default: 'out/'): ")
    #outDir = "out" if outDir == "" else outDir
    #outDir = os.path.abspath(outDir)
    #config["outDir"] = outDir


    #memory = input("Max memory (default: 200): ")
    #memory = int(memory) if memory is not "" else 200
    config["memory"] = "8G"
    

    return config


def writeConfig(config):
    with open("autoPwn.config","w") as f:
        f.write("[afl.dirs]\n")
        f.write("work = {0}\n".format(config["workDir"]))
        f.write("\n[target]\n")
        f.write("target = {0}\n".format(config["target"]))
        #f.write("cmdline = {0}\n".format(config["cmdline"]))
        f.write("\n[afl.ctrl]\n")
        f.write("file = \n")
        f.write("timeout = 200+\n")
        f.write("mem_limit = {0}\n".format(config["memory"]))
        f.write("qemu = on\n")
        f.write("threads = {0}\n".format(config['threads']))
        #f.write("cpu_affinity = {0}".format(' '.join([str(x) for x in range(config['threads'])])) + "\n")
        f.write("\n[afl.behavior]\n")
        f.write("dirty = off\n")
        f.write("dumb = off\n")
        

def readConfig(config_file):
    config = configparser.ConfigParser()
    config.read(config_file)
    newConfig = {}
    newConfig['workDir'] = config['afl.dirs']['work']
    newConfig['target'] = config['target']['target']
    #newConfig['cmdline'] = config['target']['cmdline']
    newConfig['memory'] = int(config['afl.ctrl']['mem_limit'])
    #newConfig['threads'] = len(config['afl.ctrl']['cpu_affinity'].split(" "))
    newConfig['threads'] = int(config['afl.ctrl']['threads'])
    #newConfig['cycles_done'] = 0 # Intentionally going to be wrong here to initiate path clean
    
    return newConfig

def runAFL(cmd=None):
    cmd = "start" if cmd is None else cmd

    subprocess.check_output("afl-multicore -i - -c autoPwn.config {1} {0}".format(config['threads'],cmd),shell=True)
    # It adds our python instance into the kill file too... Let's remove that :-)
    try:
        subprocess.check_output("grep -v {0} /tmp/afl_multicore.PGID.SESSION > /tmp/afl_multicore.PGID.SESSION2".format(os.getpgid(0)),shell=True)
    except:
        pass
    subprocess.check_output("mv /tmp/afl_multicore.PGID.SESSION2 /tmp/afl_multicore.PGID.SESSION",shell=True)


def collectExploits():
        exploits = os.path.abspath('exploits')
        subprocess.check_output("afl-collect -e gdb_script -j {0} -m -r -rr {1} {4} -- {2} {3}".format(config['threads'],config['outDir'],config['target'],config['cmdline'],exploits),shell=True)
        exploitMin = os.path.abspath("exploit_min")
        
        try:
            os.mkdir(exploitMin)
        except:
            pass

        for exp in glob.glob(os.path.join(exploits,"S*")):
            #print("Checking",exp)
            base = os.path.basename(exp)
            o = subprocess.check_output("afl-tmin -i {0} -o {1} -Q -m {4} -- {2} {3}".format(exp,os.path.join(exploitMin,base),config['target'],config['cmdline'],config["memory"]),shell=True)
            #print(o.decode('ascii'))

        shutil.rmtree(exploits)

        print("Completed. Exploits in directory {0}".format(exploitMin))

def collectAllPaths():
        paths = os.path.abspath('paths')
        os.mkdir(paths)

        # TODO: Handle this better. Sometimes there will be dups
        try:
            subprocess.check_output("cp {0}/*/queue/* {1}".format(config['outDir'],paths),shell=True)
        except:
            pass

        pathsCMin = os.path.abspath("paths_cmin")
        
        try:
            os.mkdir(pathsCMin)
        except:
            pass

        subprocess.check_output("afl-cmin -i {0} -o {1} -Q -m {2} -- {3} {4}".format(paths,pathsCMin,config["memory"],config["target"],config["cmdline"]),shell=True)


        pathsMin = os.path.abspath("paths_min")
        
        try:
            os.mkdir(pathsMin)
        except:
            pass

        for exp in glob.glob(os.path.join(pathsCMin,"*")):
            #print("Checking",exp)
            base = os.path.basename(exp)
            o = subprocess.check_output("afl-tmin -i {0} -o {1} -Q -m {4} -- {2} {3}".format(exp,os.path.join(pathsMin,base),config['target'],config['cmdline'],config["memory"]),shell=True)
            #print(o.decode('ascii'))

        shutil.rmtree(paths)
        shutil.rmtree(pathsCMin)

        print("Completed. Paths in directory {0}".format(pathsMin))


def setupUI():
    global console, bininfo, fuzzstats
    console = ConsoleUI()

    main_menu = modules.menu.Menu()
    main_menu.addItem("S","(S)tart searching")
    main_menu.addItem("Q","(Q)uit")

    fuzzstats = modules.fuzzerStats.FuzzerStats(fuzz)

    console.createView("MainMenu")
    console.setActiveView("MainMenu")
    console.registerModule(modules.banner.Banner(),height=20)
    bininfo = modules.binInfo.BinInfo(proj,cfg)
    console.registerModule(bininfo,height=20)
    console.registerModule(fuzzstats,height=50)
    console.registerModule(main_menu,height=100)


def doMainMenu():
    console.setActiveView("MainMenu")
    console.setPrompt("Select> ")
    
    while True:
        console.draw()
        selection = console.input()

        if selection.upper() == "S":
            doStart()

        if selection.upper() == "Q":
            doExit()

def doStart():
    """Handle starting everything up."""
    
    # Start up the fuzzer   
    fuzz.start()
    
    # Make sure to refresh our display
    signal.signal(signal.SIGALRM, checkFuzzerStatus)
    signal.alarm(CHECK_INTERVAL)
    

     
def doExit():
    # If fuzzer is alive, kill it first
    if fuzz.alive:
        fuzz.kill()
    
    exit(0)


if __name__ == "__main__":

    parser = argparse.ArgumentParser(description='Automate some basic fuzzing management')
    parser.add_argument('binary', type=str, nargs=1,
                        help = "Binary to auto fuzz")
    parser.add_argument('config_file', type=str, nargs='?',
                        help='(optional) an existing autoPwn config file to resume execution')
    parser.add_argument('--no-auto-min', dest='no_auto_min', action='store_true',
                        help='Remove auto-prune functionality. It can still be done on-demand')
    parser.set_defaults(no_auto_min=True)
    args = parser.parse_args()

    #print(args.binary[0])

    #print(args.no_auto_min)

    #preChecks()

    if args.config_file is None:
    
        config = getConfig()
    
        writeConfig(config)

    else:
        config = readConfig(args.config_file)

    # Setup the fuzzer
    print("Initializing fuzzer")
    fuzz = fuzzer.Fuzzer(args.binary[0],config['workDir'],afl_count=config['threads'])

    # Load up the binary
    print("Loading up the binary")
    proj = angr.Project(config['target'],load_options={'auto_load_libs': False})
    cfg = proj.analyses.CFG()

    setupUI()

    doMainMenu()

