#!/usr/bin/env python

import os.path
import shutil
import subprocess
import multiprocessing
import threading
import signal
import re
import glob
import argparse
import configparser
import tracer, angr, simuvex, driller, fuzzer
from ui.console import ConsoleUI
import modules.banner, modules.binInfo, modules.menu
import modules.fuzzerStats
from time import sleep

CHECK_INTERVAL = 10

def checkFuzzerStatus(signum, frame):
    
    # Refresh our display
    console.draw()    

    # Reset our alarm
    signal.alarm(CHECK_INTERVAL)

def doDrill():
    
    # Grab whatever paths we have
    paths = fuzz.queue()

    print("Found paths: " + str(paths))

    sleep(10)
    

def preChecks():
    # Checking for files that are needed
    if shutil.which("afl-fuzz") == None:
        print("Must have afl-fuzz installed: http://lcamtuf.coredump.cx/afl/")
        exit(1)

def getConfig():
    config = {}
    config['cycles_done'] = 0
    print("Setting up fuzz configuration")

    #target = input("Target Binary (full or relative path): ")
    target = args.binary[0]

    # Change it to abs path
    target = os.path.abspath(target)
    config["target"] = target
    
    # Ensure the file exists
    if not os.path.isfile(target):
        print("That file doesn't appear to exist...")
        exit(1)


    #cmdline = input("Command line args: ")
    #config["cmdline"] = cmdline

    defaultThreads = multiprocessing.cpu_count()
    #threads = input("Number of cores (default: {0}): ".format(defaultThreads))
    #threads = defaultThreads if threads == "" else int(threads)
    config["threads"] = defaultThreads
 

    #inDir = input("Test Case Dir (default: 'in/'): ")
    #inDir = "in" if inDir == "" else inDir
    workDir = os.path.abspath("work")
    config["workDir"] = workDir


    #outDir = input("Test Case Dir (default: 'out/'): ")
    #outDir = "out" if outDir == "" else outDir
    #outDir = os.path.abspath(outDir)
    #config["outDir"] = outDir


    #memory = input("Max memory (default: 200): ")
    #memory = int(memory) if memory is not "" else 200
    config["memory"] = "8G"
    

    return config


def writeConfig(config):
    with open("autoPwn.config","w") as f:
        f.write("[afl.dirs]\n")
        f.write("work = {0}\n".format(config["workDir"]))
        f.write("\n[target]\n")
        f.write("target = {0}\n".format(config["target"]))
        #f.write("cmdline = {0}\n".format(config["cmdline"]))
        f.write("\n[afl.ctrl]\n")
        f.write("file = \n")
        f.write("timeout = 200+\n")
        f.write("mem_limit = {0}\n".format(config["memory"]))
        f.write("qemu = on\n")
        f.write("threads = {0}\n".format(config['threads']))
        #f.write("cpu_affinity = {0}".format(' '.join([str(x) for x in range(config['threads'])])) + "\n")
        f.write("\n[afl.behavior]\n")
        f.write("dirty = off\n")
        f.write("dumb = off\n")
        

def readConfig(config_file):
    config = configparser.ConfigParser()
    config.read(config_file)
    newConfig = {}
    newConfig['workDir'] = config['afl.dirs']['work']
    newConfig['target'] = config['target']['target']
    #newConfig['cmdline'] = config['target']['cmdline']
    newConfig['memory'] = int(config['afl.ctrl']['mem_limit'])
    #newConfig['threads'] = len(config['afl.ctrl']['cpu_affinity'].split(" "))
    newConfig['threads'] = int(config['afl.ctrl']['threads'])
    #newConfig['cycles_done'] = 0 # Intentionally going to be wrong here to initiate path clean
    
    return newConfig

def runAFL(cmd=None):
    cmd = "start" if cmd is None else cmd

    subprocess.check_output("afl-multicore -i - -c autoPwn.config {1} {0}".format(config['threads'],cmd),shell=True)
    # It adds our python instance into the kill file too... Let's remove that :-)
    try:
        subprocess.check_output("grep -v {0} /tmp/afl_multicore.PGID.SESSION > /tmp/afl_multicore.PGID.SESSION2".format(os.getpgid(0)),shell=True)
    except:
        pass
    subprocess.check_output("mv /tmp/afl_multicore.PGID.SESSION2 /tmp/afl_multicore.PGID.SESSION",shell=True)


def collectExploits():
        exploits = os.path.abspath('exploits')
        subprocess.check_output("afl-collect -e gdb_script -j {0} -m -r -rr {1} {4} -- {2} {3}".format(config['threads'],config['outDir'],config['target'],config['cmdline'],exploits),shell=True)
        exploitMin = os.path.abspath("exploit_min")
        
        try:
            os.mkdir(exploitMin)
        except:
            pass

        for exp in glob.glob(os.path.join(exploits,"S*")):
            #print("Checking",exp)
            base = os.path.basename(exp)
            o = subprocess.check_output("afl-tmin -i {0} -o {1} -Q -m {4} -- {2} {3}".format(exp,os.path.join(exploitMin,base),config['target'],config['cmdline'],config["memory"]),shell=True)
            #print(o.decode('ascii'))

        shutil.rmtree(exploits)

        print("Completed. Exploits in directory {0}".format(exploitMin))

def collectAllPaths():
        paths = os.path.abspath('paths')
        os.mkdir(paths)

        # TODO: Handle this better. Sometimes there will be dups
        try:
            subprocess.check_output("cp {0}/*/queue/* {1}".format(config['outDir'],paths),shell=True)
        except:
            pass

        pathsCMin = os.path.abspath("paths_cmin")
        
        try:
            os.mkdir(pathsCMin)
        except:
            pass

        subprocess.check_output("afl-cmin -i {0} -o {1} -Q -m {2} -- {3} {4}".format(paths,pathsCMin,config["memory"],config["target"],config["cmdline"]),shell=True)


        pathsMin = os.path.abspath("paths_min")
        
        try:
            os.mkdir(pathsMin)
        except:
            pass

        for exp in glob.glob(os.path.join(pathsCMin,"*")):
            #print("Checking",exp)
            base = os.path.basename(exp)
            o = subprocess.check_output("afl-tmin -i {0} -o {1} -Q -m {4} -- {2} {3}".format(exp,os.path.join(pathsMin,base),config['target'],config['cmdline'],config["memory"]),shell=True)
            #print(o.decode('ascii'))

        shutil.rmtree(paths)
        shutil.rmtree(pathsCMin)

        print("Completed. Paths in directory {0}".format(pathsMin))


def setupUI():
    global console, bininfo, fuzzstats
    console = ConsoleUI()

    main_menu = modules.menu.Menu()
    main_menu.addItem("S","(S)tart searching")
    main_menu.addItem("Q","(Q)uit")

    fuzzstats = modules.fuzzerStats.FuzzerStats(queues)

    console.createView("MainMenu")
    console.setActiveView("MainMenu")
    console.registerModule(modules.banner.Banner(),height=20)
    bininfo = modules.binInfo.BinInfo(proj,cfg)
    console.registerModule(bininfo,height=20)
    console.registerModule(fuzzstats,height=50)
    console.registerModule(main_menu,height=100)


def doMainMenu():
    console.setActiveView("MainMenu")
    console.setPrompt("Select> ")
    
    while True:
        console.draw()
        selection = console.input()

        if selection.upper() == "S":
            doStart()

        if selection.upper() == "Q":
            doExit()

def doStart():
    """Handle starting everything up."""
    
    # Start up the fuzzer   
    queues['engine'].put(["fuzzer_start",None])
    
    # Make sure to refresh our display
    signal.signal(signal.SIGALRM, checkFuzzerStatus)
    signal.alarm(CHECK_INTERVAL)
    

     
def doExit():
    # Kill the fuzzing
    queues['engine'].put(["fuzzer_kill",None])
    
    # Race condition
    sleep(0.2)

    exit(0)

##########################
# Fuzzing Thread Section #
##########################

def engine(binary,workDir,threads,queues=None):
    # Setup the fuzzer
    print("Initializing fuzzer")
    fuzz = fuzzer.Fuzzer(binary,workDir,afl_count=threads)

    drilling = False

    while True:

        command, replyto = queues['engine'].get()

        replyto = queues[replyto] if replyto is not None else None

        if command == "fuzzer_alive":
            replyto.put(fuzz.alive)

        elif command == "fuzzer_stats":
            replyto.put(fuzz.stats)

        elif command == "fuzzer_start":
            fuzz.start()

        elif command == "fuzzer_kill":
            if fuzz.alive:
                fuzz.kill()
        
        elif command == "driller_alive":
            replyto.put(drilling)


def watcher(queues):
    me = "watcher"
    
    while True:

        sleep(5)

        # If we haven't started yet, just pass
        queues['engine'].put(["fuzzer_alive",me])
        fuzzer_alive = queues[me].get()
        if not fuzzer_alive:
            continue
        
        # Grab the fuzzer stats
        queues['engine'].put(["fuzzer_stats",me])
        fuzzer_stats = queues[me].get()

        # If we have no more pending favs, we should move on.
        pending_favs = sum(int(fuzzer_stats[x]['pending_favs']) for x in fuzzer_stats)

        # It's time to drill for some more
        if pending_favs == 0:
            print("Should start drilling now")



################
# Main Section #
################



if __name__ == "__main__":

    parser = argparse.ArgumentParser(description='Automate some basic fuzzing management')
    parser.add_argument('binary', type=str, nargs=1,
                        help = "Binary to auto fuzz")
    parser.add_argument('config_file', type=str, nargs='?',
                        help='(optional) an existing autoPwn config file to resume execution')
    parser.add_argument('--no-auto-min', dest='no_auto_min', action='store_true',
                        help='Remove auto-prune functionality. It can still be done on-demand')
    parser.set_defaults(no_auto_min=True)
    args = parser.parse_args()

    #print(args.binary[0])

    #print(args.no_auto_min)

    #preChecks()

    if args.config_file is None:
    
        config = getConfig()
    
        writeConfig(config)

    else:
        config = readConfig(args.config_file)

    # Setup some queues
    queues = {
        'engine': multiprocessing.Queue(),
        'fuzzstats': multiprocessing.Queue(),
        'watcher': multiprocessing.Queue(),
    }

    p = multiprocessing.Process(target=engine,args=(args.binary[0],config['workDir'],config['threads']),kwargs={'queues':queues})
    p.daemon = True
    p.start()

    # Load up the binary
    print("Loading up the binary")
    proj = angr.Project(config['target'],load_options={'auto_load_libs': False})
    cfg = proj.analyses.CFG()

    setupUI()

    # Watch for the fuzzing to stall. This thread kicks off change into drilling
    p = multiprocessing.Process(target=watcher,args=(queues,))
    p.daemon = True
    p.start()

    doMainMenu()

